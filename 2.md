0. useReducer
1. customHook de useReducer
2. Contextos y providers
3. useContext
4. use (React 19, para Context)
5. <title> y dem谩s
6. useCallback
7. useMemo
10. E2E testing
11. Testing Unitario


## Estilando un poco

-> Products.jsx

```jsx
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, minmax(200px, 1fr))', gap: '1rem' }}>
```

-> MangoCard.jsx

```jsx
<picture>
  <img
    className="mango-card__img"
    src={img}
    alt="Chico con jersey marr贸n"
    style={{ aspectRatio: '1/1' }}
  />
</picture>
```

-> App.css

```css
.mango-card__img {
  aspect-ratio: 1/1;
  object-fit: contain;
}
```

## Creamos un Cart

-> components/Cart.jsx

```jsx
export function Cart ({ cart, onModifyQuantity, onRemoveFromCart }) {
  return (
    <aside style={{
      position: 'fixed',
      top: 0, right: 0,
      width: '300px', height: '100vh',
      background: '#eee',
      color: 'black'
    }}>
      <h2>Carrito </h2>
      {
        cart.map(({ id, name, img, quantity }) => (
          <article key={id}>
            <div>
              <img src={img} alt={name} style={{ width: '100px', height: '100px', objectFit: 'contain' }} />
              <h4>{name}</h4>
            </div>
            <div style={{ display: 'flex', flexDirection: 'row', gap: '1rem', justifyContent: 'center', alignContent: 'center' }}>
              <button onClick={() => onModifyQuantity({ id }, quantity - 1)}>-</button>
              <span>{quantity}</span>
              <button onClick={() => onModifyQuantity({ id }, quantity + 1)}>+</button>
              <button onClick={() => onRemoveFromCart({ id })}>Remove</button>
            </div>
          </article>
          
        ))
      }
    </aside>
  )
}
```

-> App.jsx - Creamos state y usamos componente Cart

```jsx
const [cart, setCart] = useState([])

const handleAddToCart = (product) => {
  setCart([...cart, {...product, quantity: 1 }])
}

const handleModifyQuantity = (product, quantity) => {
  const newCart = cart.map((cartProduct) => {
    if (cartProduct.id === product.id) {
      return { ...cartProduct, quantity }
    }

    return cartProduct
  })

  setCart(newCart)
}

const handleRemoveFromCart = (product) => {
  const newCart = cart.filter((cartProduct) => cartProduct.id !== product.id)
  setCart(newCart)
}
```

-> Uso en App.jsx

```jsx
<Products
  cart={cart}
  loadingProducts={loadingProducts}
  products={filteredProducts}
  onAddToCart={handleAddToCart}
  onRemoveFromCart={handleRemoveFromCart}
/>

<Cart
  cart={cart}
  onModifyQuantity={handleModifyQuantity}
  onRemoveFromCart={handleRemoveFromCart}
/>
```

-> A帽adir en Products.jsx

```jsx
<MangoCard
  ...
  added={cart.some(product => product.id === id)}
  onAddToCart={onAddToCart}
  onRemoveFromCart={onRemoveFromCart}
/>
```

-> Modificar el MangoCard.jsx

```jsx
<picture>
  <img
    className="mango-card__img"
    src={img}
    alt="Chico con jersey marr贸n"
    style={{ aspectRatio: '1/1' }}
  />
</picture>
```

## Usar useReducer

```jsx
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TO_CART':
      return [...state, { ...action.product, quantity: 1 }]
    case 'MODIFY_QUANTITY':
      return state.map((cartProduct) => {
        if (cartProduct.id === action.product.id) {
          return { ...cartProduct, quantity: action.quantity }
        }
        return cartProduct
      })
    case 'REMOVE_FROM_CART':
      return state.filter((cartProduct) => cartProduct.id !== action.product.id)
    default:
      return state
  }
}

const [cart, dispatch] = useReducer(cartReducer, [])

const handleAddToCart = (product) => {
  dispatch({ type: 'ADD_TO_CART', product })
}

const handleModifyQuantity = (product, quantity) => {
  dispatch({ type: 'MODIFY_QUANTITY', product, quantity })
}

const handleRemoveFromCart = (product) => {
  dispatch({ type: 'REMOVE_FROM_CART', product })
}
```

## Crear Custom Hook useCart.jsx

```jsx
import { useReducer } from "react"

export const useCart = () => {
  const cartReducer = (state, action) => {
    switch (action.type) {
      case 'ADD_TO_CART':
        return [...state, { ...action.product, quantity: 1 }]
      case 'MODIFY_QUANTITY':
        return state.map((cartProduct) => {
          if (cartProduct.id === action.product.id) {
            return { ...cartProduct, quantity: action.quantity }
          }
          return cartProduct
        })
      case 'REMOVE_FROM_CART':
        return state.filter((cartProduct) => cartProduct.id !== action.product.id)
      default:
        return state
    }
  }

  const [cart, dispatch] = useReducer(cartReducer, [])

  const handleAddToCart = (product) => {
    dispatch({ type: 'ADD_TO_CART', product })
  }

  const handleModifyQuantity = (product, quantity) => {
    dispatch({ type: 'MODIFY_QUANTITY', product, quantity })
  }

  const handleRemoveFromCart = (product) => {
    dispatch({ type: 'REMOVE_FROM_CART', product })
  }

  return { handleAddToCart, handleModifyQuantity, handleRemoveFromCart, cart }
}
```

-> App.jsx

```jsx
const {
  cart,
  handleAddToCart,
  handleModifyQuantity,
  handleRemoveFromCart
} = useCart()
```

## Refactorizaci贸n del use-cart.jsx

1. Extraer el reducer
2. Pasar a condicionales `if` en lugar de `switch`
3. Usar `.with` en lugar de `.map`
4. Evitar Magic Strings

```jsx
import { useReducer } from "react"

const ACTIONS = {
  ADD_TO_CART: Symbol(),
  MODIFY_QUANTITY: Symbol(),
  REMOVE_FROM_CART: Symbol()
}

const cartReducer = (state, { type, payload }) => {
  const { product, quantity } = payload

  if (type === ACTIONS.ADD_TO_CART) {
    return [...state, { ...product, quantity: 1 }]
  }

  if (type === ACTIONS.MODIFY_QUANTITY) {
    const index = state.findIndex((cartProduct) => cartProduct.id === product.id)
    if (index === -1) return state
    return state.with(index, { ...state[index], quantity })
  }

  if (type === ACTIONS.REMOVE_FROM_CART) {
    return state.filter((cartProduct) => cartProduct.id !== product.id)
  }
  
  return state
}

export const useCart = () => {
  const [cart, dispatch] = useReducer(cartReducer, [])

  const handleAddToCart = (product) => {
    dispatch({ type: ACTIONS.ADD_TO_CART, payload: { product } })
  }

  const handleModifyQuantity = (product, quantity) => {
    dispatch({ type: ACTIONS.MODIFY_QUANTITY, payload: { product, quantity }})
  }

  const handleRemoveFromCart = (product) => {
    dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: { product }})
  }

  return { handleAddToCart, handleModifyQuantity, handleRemoveFromCart, cart }
}
```

## Intentando usar el Cart en otro sitio

-> MangoCart.jsx

```jsx
export function MangoCard({ img, id, name }) {
  const {handleAddToCart, handleRemoveFromCart, cart} = useCart()

  const added = cart.some(product => product.id === id)

  const handleClick = () => {
    if (added) {
      handleRemoveFromCart({ id, name, img })
    } else {
      handleAddToCart({ id, name, img })
    }
  }
```

## Creando un Contexto: Diagrama

https://dmitripavlutin.com/90649ae4bdf379c482ad24e0dd220bc4/react-context-3.svg
https://miro.medium.com/v2/resize:fit:866/1*5KZjV6GR2ua-vlc1fiMNPw.png

##Creando un Contexto

-> contexts/user.jsx

```jsx
import { createContext } from "react";

export const UserContext = createContext();

export const UserProvider = ({ children }) => {
  return <UserContext.Provider value={{ isLogged: false }}>
    {children}
  </UserContext.Provider>;
}
```

-> main.jsx

```jsx
import { UserContextProvider } from './contexts/user.jsx'

createRoot(
  document.getElementById('root')
).render(
  <StrictMode>
    <UserContextProvider>
      <App />
    </UserContextProvider>
  </StrictMode>
  ,
)
```

-> uso en Header.jsx

```jsx
import { useContext } from "react";

import { Title } from "./Title";
import { UserContext } from "../contexts/user";

export function Header({ products, children }) {
  const { isLogged } = useContext(UserContext);

  return (
    <header>
      <Title as='h4' text='Mango Card' />
  
      {
        isLogged ? (
          <button style={{ backgroundColor: 'white' }}>
            Cerrar sesi贸n
          </button>
        ) : (
          <button style={{ backgroundColor: '#09f' }}>
            Iniciar sesi贸n
          </button>
        )
      }
```

## Mejorando el Contexto con un estado

```jsx
import { createContext, useState } from "react";

export const UserContext = createContext();

export const UserContextProvider = ({ children }) => {
  const [isLogged, setIsLogged] = useState(false)

  const login = () => {
    setIsLogged(true)
  }

  const logout = () => {
    setIsLogged(false)
  }

  return <UserContext.Provider value={{ isLogged, login, logout }}>
    {children}
  </UserContext.Provider>;
}
```

Usando en Header.jsx estos nuevos m茅todos:

```jsx
export function Header({ products, children }) {
  const { isLogged, login, logout } = useContext(UserContext);

  return (
    <header>
      <Title as='h4' text='Mango Card' />
  
      {
        isLogged ? (
          <button onClick={logout} style={{ backgroundColor: 'black' }}>
            Cerrar sesi贸n
          </button>
        ) : (
          <button onClick={login} style={{ backgroundColor: '#09f' }}>
            Iniciar sesi贸n
          </button>
        )
      }
```

Usando en la Cart.jsx

```jsx
export function Cart ({ cart, onModifyQuantity, onRemoveFromCart }) {
  const { isLogged } = useContext(UserContext)
  if (!isLogged) return null
```

Usar tambi茅n en MangoCard.jsx

## Mejorando el consumo del Contexto con un Custom Hook

```jsx
import { useContext } from 'react'
import { UserContext } from '../contexts/user'

export const useUser = () => {
  const context = useContext(UserContext)

  if (!context) {
    throw new Error('useUser must be used within a UserProvider')
  }

  return context
}
```

Usar `useUser` en lugar de cargar el contexto manualmente

## Creando el contexto para el Cart

```jsx
import { createContext, useReducer } from "react";

const ACTIONS = {
  ADD_TO_CART: Symbol(),
  MODIFY_QUANTITY: Symbol(),
  REMOVE_FROM_CART: Symbol()
}

const cartReducer = (state, { type, payload }) => {
  const { product, quantity } = payload

  if (type === ACTIONS.ADD_TO_CART) {
    console.log({ product })
    return [...state, { ...product, quantity: 1 }]
  }

  if (type === ACTIONS.MODIFY_QUANTITY) {
    const index = state.findIndex((cartProduct) => cartProduct.id === product.id)
    if (index === -1) return state
    return state.with(index, { ...state[index], quantity })
  }

  if (type === ACTIONS.REMOVE_FROM_CART) {
    return state.filter((cartProduct) => cartProduct.id !== product.id)
  }
  
  return state
}

export const CartContext = createContext();

export const CartProvider = ({ children }) => {
  const [cart, dispatch] = useReducer(cartReducer, [])

  const handleAddToCart = (product) => {
    dispatch({ type: ACTIONS.ADD_TO_CART, payload: { product } })
  }

  const handleModifyQuantity = (product, quantity) => {
    dispatch({ type: ACTIONS.MODIFY_QUANTITY, payload: { product, quantity }})
  }

  const handleRemoveFromCart = (product) => {
    dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: { product }})
  }

  return (
    <CartContext.Provider value={{
      handleAddToCart, handleModifyQuantity, handleRemoveFromCart, cart
    }}>{children}</CartContext.Provider>
  )
}
```

-> Envolver en `main.jsx`

```jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'

import './index.css'
import App from './App.jsx'
import { UserContextProvider } from './contexts/user.jsx'
import { CartProvider } from './contexts/cart.jsx'

createRoot(
  document.getElementById('root')
).render(
  <StrictMode>
    <CartProvider>
      <UserContextProvider>
        <App />
      </UserContextProvider>
    </CartProvider>
  </StrictMode>
  ,
)
```

-> Cambiar la implementaci贸n del `useCart` para usar el contexto

```jsx
import { useContext } from "react"
import { CartContext } from "../contexts/cart"

export const useCart = () => {
  const context = useContext(CartContext)

  if (!context) {
    throw new Error('useCart must be used within a CartProvider')
  }

  return context
}
```

# Refactor para evitar el Prop Drilling

Usar el contexto en lugar de usar el prop drilling

# React Developer Tools

1. A帽adir console.log al componente Cart.
2. 驴Por qu茅 se renderiza tantas veces?
3. Instalar React Developer Tools
4. Ense帽ar pesta帽a Components
5. Usar Profiler para ver por qu茅 se renderiza
6. Usar React.memo en Cart.jsx para evitar renders innecesarios

# useCallback

Probar a conseguir lo mismo en el MangoCard.
Activar las actualizaciones visuales en el Profiler.
Mover el uso del context al padre de MangoCard.
驴Por qu茅 se sigue renderizando? Las props cambian.

Posible arreglo:

```jsx
export const MangoCard = memo(MangoCardComponent, (prevProps, nextProps) => {
  return prevProps.added === nextProps.added
})
```

No est谩 mal, pero no es lo ideal. 驴Qu茅 pasa si cambian otras props?

```jsx
export const MangoCard = memo(MangoCardComponent, (prevProps, nextProps) => (
  prevProps.added === nextProps.added &&
  prevProps.img === nextProps.img &&
  prevProps.name === nextProps.name &&
  prevProps.id === nextProps.id
))
```

Mejor ser铆a indicar las props que debemos comparar:

```jsx
export const MangoCard = memo(MangoCardComponent, (prevProps, nextProps) => {
  const propsToCompare = ['added', 'img', 'name', 'id'];
  return propsToCompare.every(prop => prevProps[prop] === nextProps[prop]);
});
```

Pero mejor todav铆a evitar que las props cambien. Vemos que el problema est谩 en el contexto.
Vamos a explicar por qu茅 se vuelve a crear la funci贸n.

Vamos con el ejemplo de los filtros en el App.jsx.

```jsx
  const [toggle, setToggle] = useState(false)
  const [filterCategory, setFilterCategory] = useState(CATEGORIES[0])

  const filteredProducts = products.filter(product => {
    console.log({ filterCategory })
    if (filterCategory === 'all') return true

    const { category } = product
    return category === filterCategory
  })

  return (
    <>
      <button onClick={() => setToggle(!toggle)}>Toggle</button>
```

Usando useMemo:

```jsx
  const filteredProducts = useMemo(() => products.filter(product => {
    console.log({ filterCategory })
    if (filterCategory === 'all') return true

    const { category } = product
    return category === filterCategory
  }), [products, filterCategory])
```

## useCallback

```jsx
const handleAddToCart = useMemo(() => (product) => {
    dispatch({ type: ACTIONS.ADD_TO_CART, payload: { product } })
  }, [])
```

Usando `useCallback`:

```jsx
  const handleAddToCart = useCallback((product) => {
    dispatch({ type: ACTIONS.ADD_TO_CART, payload: { product } })
  }, [])

  const handleModifyQuantity = useCallback((product, quantity) => {
    dispatch({ type: ACTIONS.MODIFY_QUANTITY, payload: { product, quantity }})
  }, [])

  const handleRemoveFromCart = useCallback((product) => {
    dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: { product }})
  }, [])
```

# Playwright E2E

```
pnpm create playwright
npm init playwright@latest
```

Ejecutar tests:
```
npx playwright test
pnpm exec playwright test
```

Mostrar reportes HTML:
```
npx playwright show-report
pnpm exec playwright show-report
```

Ejecutar tests con modo UI:
```
npx playwright test --ui
pnpm exec playwright test --ui
```

# Cambiar tests

-> example.spec.js

```js
// @ts-check
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
  await page.goto('http://localhost:5173');

  await expect(page).toHaveTitle(/Playwright/);
});

test('is able to login', async ({ page }) => {
  await page.goto('http://localhost:5173');

  await page.getByText('Iniciar sesi贸n').click();

  await expect(page.getByText('Cerrar sesi贸n')).toBeVisible();
});

test('is able to add a product to the cart', async ({ page }) => {

  await page.route('https://dummyjson.com/products', async route => {
    const json = {
      "products": [
      {
        "id": 1,
        "title": "Essence Mascara Lash Princess",
        "description": "The Essence Mascara Lash Princess is a popular mascara known for its volumizing and lengthening effects. Achieve dramatic lashes with this long-lasting and cruelty-free formula.",
        "category": "beauty",
        "price": 9.99,
        "discountPercentage": 7.17,
        "rating": 4.94,
        "stock": 5,
        "tags": [
          "beauty",
          "mascara"
        ],
        "brand": "Essence",
        "sku": "RCH45Q1A",
        "weight": 2,
        "dimensions": {
          "width": 23.17,
          "height": 14.43,
          "depth": 28.01
        },
        "warrantyInformation": "1 month warranty",
        "shippingInformation": "Ships in 1 month",
        "availabilityStatus": "Low Stock",
        "reviews": [
          {
            "rating": 2,
            "comment": "Very unhappy with my purchase!",
            "date": "2024-05-23T08:56:21.618Z",
            "reviewerName": "John Doe",
            "reviewerEmail": "john.doe@x.dummyjson.com"
          },
          {
            "rating": 2,
            "comment": "Not as described!",
            "date": "2024-05-23T08:56:21.618Z",
            "reviewerName": "Nolan Gonzalez",
            "reviewerEmail": "nolan.gonzalez@x.dummyjson.com"
          },
          {
            "rating": 5,
            "comment": "Very satisfied!",
            "date": "2024-05-23T08:56:21.618Z",
            "reviewerName": "Scarlett Wright",
            "reviewerEmail": "scarlett.wright@x.dummyjson.com"
          }
        ],
        "returnPolicy": "30 days return policy",
        "minimumOrderQuantity": 24,
        "meta": {
          "createdAt": "2024-05-23T08:56:21.618Z",
          "updatedAt": "2024-05-23T08:56:21.618Z",
          "barcode": "9164035109868",
          "qrCode": "https://assets.dummyjson.com/public/qr-code.png"
        },
        "images": [
          "https://cdn.dummyjson.com/products/images/beauty/Essence%20Mascara%20Lash%20Princess/1.png"
        ],
        "thumbnail": "https://cdn.dummyjson.com/products/images/beauty/Essence%20Mascara%20Lash%20Princess/thumbnail.png"
      }
    ]}
    await route.fulfill({ json })
  })

  await page.goto('http://localhost:5173');

  await page.getByText('Iniciar sesi贸n').click();

  await page.getByText('A帽adir al carrito').click();

  await expect(page.getByText('Quitar del carrito')).toBeVisible();
})
```

# React19

```json
{
  "react": "rc",
  "react-dom": "rc"e
}
```

use -> useContext
<CartContext.Provider> -> <CartContext>
Usar Seo Tags

## Testing unitario

npm install --save-dev vitest

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'happy-dom',
    include: ['**/*.test.jsx']
  }
})
```

Nuestro primer test:

```jsx
import { describe, it, expect } from 'vitest'

describe('A truthy statement', () => {
  it('should be equal to 2', () => {
    expect(1+1).toEqual(2)
  })
})
```

Instalamos las bibliotecas para React:

```jsx
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

```jsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom/vitest' // toHaveTextContent

import { useState } from 'react'
import { expect, it, describe } from 'vitest'

const Counter = () => {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  )
}

describe('Counter', () => {
  it('should increment the count', async () => {
    render(<Counter />)

    const button = screen.getByRole('button', { name: /increment/i })
    await userEvent.click(button)

    const count = screen.getByRole('heading')
    expect(count).toHaveTextContent('1')
  })
})
```

Crear el primer test para el componente `Title`:

```jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import '@testing-library/jest-dom/vitest'

import { Title } from './Title'

describe('Title', () => {
  it('should render a default heading h3', async () => {
    render(<Title>title</Title>)

    const title = screen.getByRole('heading', { level: 3 })
    expect(title).toHaveTextContent('title')
  })

  it('should render a custom tag', async () => {
    render(<Title as='h2'>title2</Title>)

    const title = screen.getByRole('heading', { level: 2 })
    expect(title).toHaveTextContent('title2')
  })
})
```

Testing de Header.jsx

```jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'
import { Header } from './Header'
import { useUser } from '../hooks/use-user'

// Mock del hook useUser con Vitest
vi.mock('../hooks/use-user')

describe('Header', () => {
  it('should display the title, login button, and product count when logged out', () => {
    // Configurar el mock para el estado deslogueado
    useUser.mockReturnValue({
      isLogged: false,
      login: vi.fn(),
      logout: vi.fn()
    })

    const products = [{ id: 1 }, { id: 2 }, { id: 3 }]
    render(<Header products={products} />)

    // Verificar el t铆tulo
    expect(screen.getByRole('heading', { level: 4 })).toHaveTextContent('Mango Card')

    // Verificar el bot贸n de inicio de sesi贸n
    const loginButton = screen.getByRole('button', { name: /iniciar sesi贸n/i })
    expect(loginButton).toBeInTheDocument()
    expect(loginButton).toHaveStyle({ backgroundColor: '#09f' })

    // Verificar el n煤mero de productos
    expect(screen.getByText('N煤mero de productos: 3')).toBeInTheDocument()
  })

  it('should display the title, logout button, and product count when logged in', async () => {
    // Configurar el mock para el estado logueado
    const mockLogout = vi.fn()
    useUser.mockReturnValue({
      isLogged: true,
      login: vi.fn(),
      logout: mockLogout
    })

    const products = [{ id: 1 }, { id: 2 }]
    render(<Header products={products} />)

    // Verificar el t铆tulo
    expect(screen.getByRole('heading', { level: 4 })).toHaveTextContent('Mango Card')

    // Verificar el bot贸n de cierre de sesi贸n
    const logoutButton = screen.getByRole('button', { name: /cerrar sesi贸n/i })
    expect(logoutButton).toBeInTheDocument()
    expect(logoutButton).toHaveStyle({ backgroundColor: 'black' })

    // Simular clic en el bot贸n de cerrar sesi贸n
    await userEvent.click(logoutButton)
    expect(mockLogout).toHaveBeenCalled()

    // Verificar el n煤mero de productos
    expect(screen.getByText('N煤mero de productos: 2')).toBeInTheDocument()
  })
})
```